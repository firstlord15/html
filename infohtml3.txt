абзацы <р>
списки: маркированные (с маркером) <ul> и нумерованные (с числами) <ol>
заголовки: от первого уровня <h1> до шестого уровня <h6>
статьи <article>
разделы <section>
длинные цитаты <blockquote>
блоки общего назначения  <div>
___________________________________________________________________

Строчные элементы
Используются для форматирования текстовых фрагментов. Обычно содержат одно или несколько слов.

Особенности:

элементы, идущие подряд, располагаются на одной строке и переносятся на другую при необходимости
внутрь допустимо вставлять текст или другие строчные элементы, помещать блочные элементы - запрещено
Примеры:

ссылки <a>
выделенные слова <em>
важные слова <strong>
короткие цитаты <q>
аббревиатуры <abbr>
___________________________________________________________________

<dl> (description list) - тег начала и конца списка
<dt> (term) - термин
<dd> (description) - определение
 
___________________________________________________________________
src - ссылка на картинку﻿
alt - текст, который отображается вместо картинки, если она не загрузилась
title - текст, который отображается при наведении мыши на картинку
width - ширина картинки в пикселях
height - высота картинки в пикселях
___________________________________________________________________
В HTML 5 появились теги для оформления объектов ﻿с подписями﻿ - figure и figcaption. Если твоей картинке нужна подпись - пользуйся ими. 
___________________________________________________________________
Повторим: для создания ссылки необходимо использовать тег <a>. Атрибут href указывает адрес, по которому будет совершён переход.

https - так называемая «схема», обычно это название протокола. HTTPS - защищённая версия HTTP
google.com - доменное имя сайта
/doodles - путь (директория) внутри сайта

file - схема URI, предназначенная для того, чтобы адресовать файлы на локальном компьютере или в локальной сети (подробнее на Википедии)
/C:/Users/admin/Desktop/Новая%20папка/image.jpg - путь до файла. %20 - код пробела в URI-кодировании

target = "_blank" - открытие ссылки на новой вкладке.
___________________________________________________________________
#CSS

Селектор это правило, по которому будут выбраны элементы — например, мы можем обратиться ко всем параграфам или картинкам.

Свойства пишутся у конкретных селекторов между фигурными скобками в формате ключ: значение.

цвет текста - color
цвет фона - background-color
ширина - width

синтаксис простых селектронов: 

селектор {
 свойство: значение;
}

## HTML 

	<video controls=""> 
		<source src="my video.webm" type="video/webm">

	</video>

# <video></video> - для закрепление видео в сайте

# <source src="my video.webm" type="video/webm"> - это для того, чтобы указать путь видео
# <video controls=""> -- для работы видео.

<style type="text/css"> </style> --> вроде это для модернизации кода HTML

border="1" - добовляет линии обводящие таблицу, но в HTML5 вроде как убрали.

colspan - указывает сколько столбцов занимает то или иное слово.

<td rowspan="2> - rowspan обедеяет другие в той столбце которой напишим.

Методом POST так же можно отправлять данные в URL. Но, в отличие от GET, он может иметь тело - специальную "коробочку", в которую можно положить данные, которые уйдут на сервер.

Когда ты вводишь в адресной строке браузера какой-либо адрес и переходишь по нему, ты отправляешь серверу запрос, называемый GET. В таком запросе данные могут отсутствовать, как здесь: https://www.google.ru/. А вот запрос https://www.google.ru/search?q=itс+stepik содержит в себе переменную q, которая имеет значение itc stepik. В данном случае запрос отправляется на адрес https://www.google.ru/search,  а данные из полей и их названия идут после ? через знак &. Предварительно данные кодируются в URL код, чтобы сервер не перепутал служебные символы (вроде /, или ﻿&) с частью запроса.

Элемент формы создаётся парным тегом <form>

Поле задается одинарным тегом <input>

От пользователя нам могут понадобиться самые разные данные. Для удобства их сбора появились типы полей форм. Они задаются через атрибут type. (Обычно пишуться внутри input)

виды type: text-text; password-не видно что пишем; checkbox - просто клеточка для отметки; radio- точки для выбора пола к приметру; file - file); type ="reset" - кнопка для сборса; submit- кнопка для отправления данных.


тег <select> - типо списка всего: и его виды name, size, multiple. Name - работает как у переключателей; Size отвечает за то, сколько строк списка будет одновременно отображено; Атрибут multiple отвечает за то, можно ли выбрать сразу несколько вариантов из списка (как checkbox); это атрибут без значения.
Каждый элемент списка выделяется в тег <option>. Так же, как и с <input type="checkbox"> и <input type="radio"> нужно указывать атрибут value со значением, которое будет отправлено на сервер.

атрибут value - типо видов "radio" когда их > 1

Ввод E-Mail, type="email". Текстовое поле, у которого на клавиатуре мобильных устройств появляется символ @.
Номер телефона, type="tel". На мобильных устройствах открывается клавиатура с числами.
Ввод ссылки, type="url".
Числовое поле, type="number". Помимо клавиатуры с цифрами появляется возможность переключать значения поля. Атрибуты min и max определяют нижнее и верхнее возможное значение, step - шаг изменения, a value - начальное значение.
Числовой ползунок, type="range". Появляются уже указанные атрибуты min, max, step и ﻿value.
Поиск, type="search". Google Chrome добавляет крестик для очистки введенной строки. На мобильных устройствах появляется кнопка поиска.

Самый часто используемый селектор — по классу. Задаём в HTML класс элементам, к которым применить стиль:

<div class="card">
 Карточка
</div>


И теперь эти элементы можно выбрать по имени класса. Имя селектора начинается с точки:

.card {
   /* стили для всех элементов с class="card" */
   background: #333; /* фон серого цвета */
}

## Html
___________________________________________________________________
По id
Задавать стили по id - дурной тон, старайся его избегать. Тут всё тоже самое, что и с классом, только атрибут называется id:

<button id="button-go-to-top">
 Наверх
</button>

И имя селектора начинается с решётки:

#button-go-to-top {
   /* стили для элемента с id="button-go-to-top" */
   text-decoration: underline; /* подчёркивание текста */
}
___________________________________________________________________
По атрибуту 
Не самый популярный селектор, но иногда он полезен:

<button data-my-custom-attribute="my-custom-value">
 Нажми на меня
</button>
 Имя и значение атрибута пишется в квадратных скобках. Работает с любым атрибутом:

[data-my-custom-attribute="my-custom-value"] {
   color: red;
}
___________________________________________________________________
Любой элемент
Селектор * выбирает абсолютно любой элемент. Самый непопулярный селектор, обычно используется для костылей. Вряд ли он будет часто тебе нужен. Просто знай, что он есть.

* {
  margin: 0;
}

/* абсолютно всем элементам будет установлен margin: 0 */
___________________________________________________________________
Один и тот же набор свойств можно применить к разным селекторам. Пример:

button,
.button,
.cta-button {}

Нужно просто указать  через запятую все селекторы, к которым ты хочешь применить стили.
___________________________________________________________________
Можно стилизовать конкретный элемент, если у него есть определённый класс. Примеры:

p.example {}
Селектор выберет все p, у которых есть класс example.

.main.active {}
Селектор выберет все элементы с классом main, у которых также есть

и класс active. Пример такого элемента:
<div class="main active">Пример</div>
___________________________________________________________________
Если между двумя простыми селекторами стоит пробел и ничего больше, это означает вложенность на любом уровне. Пример:

.page p {
 text-decoration: underline;
}
___________________________________________________________________
Правая угловая скобка > обозначает вложенность на первом уровне. Пример:

<div class="page">
 <p>Как писал Пелевин:</p> <-- это первый
 <div class="quote">
  <p>                      <-- это второй
   Человек привык видеть дьявола везде, кроме зеркала и телевизора.
  </p>
 </div>
</div>

___________________________________________________________________
Хороший способ понимать смысл составных селекторов - читать их справа налево.

Давай попробуем разобраться на примере:

.page > .part {}

Этот селектор выберет все элементы .part, которые находятся на первом уровне вложенности в .page. Здесь и дальше, вместо того, чтобы писать «элемент с class="part"», мы будем писать просто .part﻿ - точка вначале подразумевает, что это имя класса.

Ещё пример:
.main .side-menu .menu-item {}
Селектор применится ко всем элементам .menu-item, которые находятся внутри элементов .side-menu, которые находятся внутри элементов .main.
___________________________________________________________________
﻿input[type="password"] {}
﻿Этот селектор выберет все элементы <input type="password">

Для того, чтобы выбрать элемент, который находится сразу после другого элемента, используется знак +. Пример:

img + p {
 margin-top: 0;
 font-style: italic;
}
Этот код применит стили во всех <p>, идущих сразу после <img>:

<img src="https://www.google.ru/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" />
<p>Это лого гугла</p>
<p>А это просто абзац</p>
____________________________________________________________________
Любой соседний элемент
Для того, чтобы выбрать элемент, который находится после другого элемента, используется знак ~. Пример:

img ~ p {
 margin-top: 0;     <-- Это
 font-style: italic;<-- И Это
}
Этот код применит стили во всех <p>, идущих после <img>, даже если между img и p есть другие элементы.
____________________________________________________________________

## Chromium DevTools - описание частей 

Дерево элементов. На этом курсе нам понадобится только вкладка "Elements". В ней отображаются узлы DOM-дерева (HTML-элементы) и их стили. При наведении на элемент из дерева, он будет подсвечен на странице. Можно увидеть контент, границы и отступы элемента. При двойном клике на содержимое элемента, можно его редактировать.

Панель со стилями. Мы будем использовать её, чтобы отлаживать наши домашние работы. В этой панели отображаются все CSS-свойства, которые применены к выбранному элементу, а так же его блочная модель.

Поиграйся с этой штукой: повыбирай разные элементы в дереве, попробуй менять и добавлять значения CSS-свойств в панели стилей.

Если во время выполнения задания, твой код работает не так, как нужно, попытайся найти причину через DevTools, перед тем, как задавать вопрос в комментарии или учебный чат.
____________________________________________________________________
#CSS

font-family - смена шрифта.

Но у такого подхода есть одна проблема: если на устройстве пользователя нет этого шрифта, то он не увидит текста.

Эта проблема решается с помощью fallback (фоллбэк):

p {
   font-family: 'Roboto', 'Helvetica Nue', sans-serif;
} 

p {
	/*background-image: url(image/image.jpg); */ => /*это изменения фона на любое фото которое я скачал*/ 
	
	text-align: center; => /* это держит все в центре*/
	width: 300px; /* => а это двигает текст от левого бока на правую, в зависимости от кол-во px. */
}

p {
	/*background-color: ; => это для изменения цвета фона*/
	text-decoration: underline; => /*- меняет текст, его стиль и т.д.*/
	/*margin-bottom: 10px;*/ => /* Отступ между в p к примеру, можно менять отступ его фона*/	
}

p{
	width: 100%; /* таким образом мы укащываем размер input - относительно width to from*/
	padding: 10px; /* Ширина "Внутрений отступ берет" - сказал*/
	margin-bottom: 10px; /* Отсутп между inputами  */	
	margin-top: 10px; /* хз */
	font-weight: 300; /* Это для задачи толшины текста */
	height: 100vw; /* отступ между фонами */
	background-repeat: no-repeat; /* команда для отмены повторений фото в фоне */
	background-repeat: repeat-x; /* команда для отмены повторений фото в фоне, только по горизонтальи можно */
	background-repeat: no-repeat-y; /* команда для отмены повторений фото в фоне, только по вертикали можно */
	background-size: 100% 100%; - /* Так мы меняем размер на x and y */
	background-position: 10px 100px; /* так мы меняем положения фона */
	background-attachment: fixed; /* он сделал так чтобы с какой стороны не глянь на фото она будет одинаковым, легче увидеть *
}
background: linear-gradient(to right, #FC8900, white); /* тут мы делаем градиент, to right/left нужно направление задать, и два цвета, все через "," */
  /* background-size отвечает за размер картинки, cover - картинка растягивается на весь блок, сохраняя пропорции */
_____________________________________________________________________
#HTML 

Разница между id и class

id - может даться только одному элементу
class - можеть даться нескольким элементам
_____________________________________________________________________
display: none; - элемент перестаёт отображаться на странице.

display: block; - блочный элемент. Ему можно задать ширину, высоту, границы, отступы.

display: inline; - строчный элемент. Задание ширины и высоты не влияет на inline элементы. Задание границ и отступов будет изменять положение окружающего текста, но не будет влиять на положение окружающих блочных элементов.

display: inline-block; - что-то среднее между блочным и строчным элементом. Ему можно задать ширину, высоту, границы и отступы, но он не будет создавать перенос строки до и после себя, в отличие от блочных элементов. С помощью этого типа можно распологать блоки горизонтально в ряд.

flex и inline-flex - это флексбоксы. Про них расскажем в уроке «Flexbox» в модуле «Продвинутая вёрстка». Элементы внутри них располагаются по определённым правилам, но снаружи они ведут себя как блоки и инлайн-блоки соотвественно.

В дальнейшем элементы с display block, inline-block, flex и inline-flex мы будем называть просто «блоки».

Блокам можно задать:

ширину (width) и высоту (height)
отступы: внутренние (padding) и внешние (margin)
границы (border)

margin - внешний отступ;
border - граница, между внутренним и внешним;
padding - внутренний отступ, под этим отступом продолжается фон элемента;
content - содержимое элемента;
_____________________________________________________________________
## Значения overflow

# Свойство overflow управляет отображением содержания блочного элемента при переполнении.

overflow: visible; - отображается все содержание блока, даже за пределами установленной высоты и ширины.

overflow: hidden; - отображается только область внутри блока, остальное будет скрыто.

overflow: scroll; - всегда добавляются полосы прокрутки, даже если контент помещается.

overflow: auto; - полосы прокрутки добавляются только при необходимости.
_____________________________________________________________________
## float

#float. Оно задаёт, по какому краю (левому или правому) будет выровнен элемент. С противоположной стороны его будут обтекать другие элементы - текст и блоки.

left - выравнивание по левой стороне, обтекание справа,
right  - выравнивание по правой стороне, обтекание слева,
none - выравнивание не задаётся (нужно, чтобы сбросить ранее заданное значение).
_____________________________________________________________________
## Clearfix

При использовании свойства float, новички испытывают проблемы. И все они вызваны нелогичным принципом работы float. Рассмотрим несколько проблем и попытаемся их решить.

Проблема 1
Родительский блок, который содержит только элементы со свойством float, "схлопывается" и принимает высоту равную нулю.

Проблема 2
Если в родительском блоке помимо "плавающих" (floating) элементов есть статические элементы, к которым мы не применяли float, то высота родителя станет равной высоте этих статических элементов

Проблема 3
Следствие проблемы 2. Такие "вываливающиеся" блоки будут обтекаться контентом блоков, которые идут после родительского.

Решение
Чтобы избавиться от этих проблем, необходимо после "плавающих" блоков очищать обтекания, чтобы последующие элементы не стали обтекать "плавающие" блоки.

Самое простое решение - очищающий блок. После плавающих блоков нужно добавить еще один блок и задать ему CSS:

clear: both;
_____________________________________________________________________
## Clearfix 2

распоркой или псевдораспоркой.

Вариант с распоркой. Добавляем после зафлоаченных блоков пустой элемент-распорку со свойством clear:both.  Этот элемент видит колонки, не даёт им пройти через себя, а заодно и растягивает родительский блок по высоте.
Для таких распорок прижилось специальное название класса — clearfix.

Вариант с псевдораспоркой.  Этот способ с псевдораспоркой позволяет избавиться от дополнительного элемента - распорки. Для эгото родительскому контейнеру задаём класс clearfix со следующими свойствами:

.clearfix::after {
            content: "";
            display: table;
            clear: both;
          }

_____________________________________________________________________
## Позиционирование()

Позиционирование определяет, к какой части страницы элемент будет «прикреплён».

Тип позиционирования задаётся с помощью свойства position. Разберём типы позиционирования.

Статическое позиционирование (static)
Этот тип стоит у элементов по умолчанию. Элемент располагается в потоке относительно остальных элементов на странице. В потоке, то есть в таком порядке, что он идёт после элементов, которые объявлены перед ним. И элементы, которые объявлены после него, идут после него.

<h1>Заголовок</h1>
<p>Абзац</p>


Вроде бы очевидно, что если заголовок объявлен раньше абзаца, то он будет под заголовком. Да? Да, но только для этого типа позиционирования.

Абсолютное позиционирование (absolute)
Забавно, что абсолютное позиционирование - тоже относительное. Но задаётся оно по-другому.

Положение абсолютного блока задаётся относительно страницы или относительно элемента с position: relative, в которой он вложен. Положение такого блока задаётся с помощью свойств top, right, bottom, left.

Например, расположим абзац из примера выше вверху экрана.  Для HTML кода из примера выше:



CSS:

p {
  position: absolute;
  top: 0;
}
Элементы со статическим позиционированием игнорируют абсолютные блоки, которые как бы "вываливаются" из потока и живут своей собственной жизнью. Как будто существуют на своём собственном слое. ﻿

Фиксированное позиционирование (fixed)
Задаётся так же, как и абсолютное, но блок прикрепляется не к странице, а к экрану. То есть при прокрутке страницы он остаётся на своём месте. Пример - шапка на степике.

Relative позиционирование (position: relative)
Положение элемента устанавливается относительно его исходного места в потоке. Свойства left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. А ещё оно работает как родитель, относительно которого можно задавать абсолютную позицию блокам, которые в него вложены.
\
Вот признаки элемента, к которому применимо абсолютное позиционирование:

Элемент сложно или невозможно расположить правильно без использования абсолютного позиционирования (чёткое понимание этого придёт во время практики, просто откладывай position: absolute на крайний случай).
Положение элемента зависит от границ его родителя.
От его положения не зависят другие элементы.
_____________________________________________________________________

##position: absolute
# способ использования pasition

.button {
  position: absolute;
  right: 16px;
  top: 20px;
}

#

.button {
  text-align: right;
  box-sizing: border-box;
  padding: 10px 20px;
}
_____________________________________________________________________
# важно, посмотри, что-то интересное, глянь

Старайся избегать установки width и height вручную. Большинство размеров можно выразить через margin и padding. Исключение - картинки и фиксированный контейнер страницы.
Свойство position можно задать только для шапки.
Подключи к своей странице normalize.css, чтобы сделать изначальные стили одинаковыми во всех браузерах.
_____________________________________________________________________
## display: flex

# flex-grow: /* это измеряет весь объем и разделяет на то сколько всех их, у кого больше значения 
flex-grow - тот будет больше, а другие относительно меньше */



# justify-content: /* этой командой удобно двигать по x координатe, maybe. */

flex-start: Элементы выравниваются по левой стороне контейнера.
flex-end: Элементы выравниваются по правой стороне контейнера.
center: Элементы выравниваются по центру контейнера.
space-between: Элементы отображаются с одинаковыми отступами между ними.
space-around: Элементы отображаются с одинаковыми отступами вокруг них.
space-eventy: поближе первых двух
space-evenly; /*это выравнивает все ровно-ровно*/

# align-items: /* этим удобно двигать по координате y */



flex-start: Элементы выравниваются по верхнему краю контейнера.
flex-end: Элементы выравниваются по нижнему краю контейнера.
center: Элементы выравниваются вертикально по центру контейнера.
baseline: Элементы отображаются на базовой линии контейнера.
stretch: Элементы растягиваются, чтоб заполнить контейнер.

Это может запутать, но align-content отвечает за расстояние между рядами, в то время как align-items отвечает за то, как элементы в целом будут выровнены в контейнере. Когда только один ряд, align-content ни на что не влияет.

# flex-direction

row: Элементы размещаются по направлению текста.
row-reverse: Элементы отображаются в обратном порядке к направлению текста.
column: Элементы распологаются сверху вниз.
column-reverse: Элементы распологаются снизу вверх.
_____________________________________________________________________

при display: flex;

можно задать order: и менять другие элементы: 
-1 в лево, 0 центер, 1 право.

Еще одно свойство, которое ты можешь применить к определенному элементу это align-self. Это свойство принимает те же значения, что и align-items

Еще один тег раздвинь их с помощью свойства flex-wrap, которое принимает следующие значения:

nowrap: Размеры элементов устанавливаются автоматически, чтоб они поместились в один ряд.
wrap: Элементы автоматически переносятся на новую строку.
wrap-reverse: Элементы автоматически переносятся на новую строку, но строки расположены в обратном порядке.

Два свойства flex-direction и flex-wrap используются так часто вместе, что было создано свойство flex-flow для их комбинирования. Это свойство принимает значения двух этих свойств, разделеные пробелом.

Например, ты можешь использовать flex-flow: row wrap, чтоб элементы располагались в ряд и автоматически переносились на новую строку.

Попробуй использовать flex-flow, чтоб повторить предыдущий уровень.
_____________________________________________________________________

# Анимация(animation)

За анимацию отвечает свойство transition. Его значние записывается так:

свойство, изменения которого нужно анимировать (если нужно анимировать несколько, можно написать all)
продолжительность анимации в секундах (рекомендуется не ставить её больше 0.3 секунды)
функция плавности, подробнее здесь: https://easings.net/ru
Вот полный список доступных для анимаций свойств: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties

exemple:
 
button {
    border-radius: 4px;
    transition: border-radius 0.5s ease-in;
}

button:hover {
    border-radius: 16px;
}

:hover - появляется при наведении мышки
:active - появляется при нажатии на элемент
:focus - появляется при фокусировке на элементе (например, когда выбрано поле ввода текста)
______________________________________________________________________________________________
## Text:HTML

font-weight: 600; /* толшина текста */
font-family: unset;
/*white-space: pre-wrap;*/ /* Этот код заставляет писать его так, как он написан в коде и с переносом по строкам*/
/*white-space: wrap; *//* пологаю это пишется с переносом по строкам */
			
white-space: pre; /* как в мы написали в коде, но без переноса по строкам */
text-decoration: underline; /* декорация текста, к примеру линии под текстом(выдиление) */
text-align: center; /* положение текста */
text-transform: uppercase; /* вроде еще какой-то вид шрифтов или размеров. */
text-shadow: 1px 1px 30px grey; /* ставит тень сзади текста */ 
/* первый - положение x, второй - положение y, третий - размытость тени */

font-family: fantasy;
/*white-space: nowrap; *//* Этот код заставляет писать все в одной строке, то есть тут нет переноса по строкам */

margin: 20px; /* отступ со всех сторон, внешний */
padding: 20px; внутрений отступ
______________________________________________________________________________________

flex-shrink — свойство CSS, которое определяет фактор сжатия flex-элемента. Flex-элементы будут заполнять контейнер в зависимости от значения flex-shrink, когда стандартная ширина flex-элементов шире, чем flex-контейнер.
________________________________________________

# Синтаксис width

/* <length> значения */
width: 300px;
width: 25em;

/* <percentage> значения */
width: 75%;

/* Значения-ключевые слова */
width: 25em border-box;
width: 75% content-box;
width: max-content;
width: min-content;
width: available;
width: fit-content;
width: auto;

/* Глобальные значения */
width: inherit;
width: initial;
width: unset;

одно из следующих ключевых слов: available, min-content, max-content, fit-content, auto.

<length> или <percentage>. За ними так же могут быть указаны одни из следующих ключевых слов: border-box, content-box.

Значения: 

<length>

Ширина - фиксированная величина.
<percentage>
Ширина в процентах - размер относительно ширины родительского блока.

border-box 
Если присутствует, то предшествующие <length> или <percentage> применяются к области рамки элемента.

content-box 
Если присутствует, то предшествующие <length> или <percentage> применяются к внутренней области элемента.

auto
Браузер рассчитает и выберет ширину для указанного элемента.

fill 
Использует fill-available размер строки или fill-available размер блока, в зависимости от способа разметки.

max-content 
Внутренняя максимальная предпочтительная ширина.
min-content 
Внутренняя минимальная ширина.

available 
Ширина содержащего блока минус горизонтальные margin, border и padding.

fit-content 
Наибольшее из:
внутренняя минимальная ширина
меньшая из внутренней предпочтительной ширины и доступной ширины
______________________________________________________________________________________

В веб-разработке (разработке сайтов и браузерных приложений) существует два основных направления: фронтенд и бэкенд.

Фронтенд отвечает за тот код, который выполняется на стороне пользователя, то есть на его устройстве - компьютере или телефоне. А бэкенд отвечает за серверную часть — обработку запросов пользователя и хранение данных.
______________________________________________________________________________________

#flexboxgrid2

Используй CSS-сетку flexboxgrid2. Чтобы её подключить, просто добавь этот код в head:

<link rel="stylesheet" href="https://unpkg.com/flexboxgrid2@7.2.1/flexboxgrid2.min.css">
______________________________________________________________________________________

Тег <nav> задает навигацию по сайту. Если на странице несколько блоков ссылок, то в <nav> обычно помещают приоритетные ссылки. Также допустимо использовать несколько тегов <nav> в документе. Запрещается вкладывать <nav> внутрь <address>.

transparent - прозрачный
часто в самом начале пишем style body 